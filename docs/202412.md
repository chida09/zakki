# 20241201
## TS Options
- `esModuleInterop`
- moduleをCommonJSで指定する時
- `import * as myModule from './myModule';`
- `import myModule from './myModule';`
- のように指定できるようになる

詳しくはまた後日調べよう

# 20241204
 - 関数コンポーネントではクロージャ（関数内の関数）は再描画時に参照が変わるため useCallback と使ってメモ化するか、コンポーネントの外で定義するのが推奨される
 - フロントエンドは実装の詳細までテストしないと思っているが、整理したいためこれ読んでおく
   - https://kentcdodds.com/blog/testing-implementation-details
 - GraphQLで型が欲しい場合は、Fragment化すればそれ単体で使える


関数コンポーネントではクロージャ（関数内の関数）は再描画時に参照が変わるため useCallback と使ってメモ化するか、コンポーネントの外で定義するのが推奨されるについて

React関数コンポーネントにおいて、コンポーネント内で定義された関数は、コンポーネントが再レンダリングされるたびに新しい関数インスタンスが作成されます。これは以下のような影響があります：

1. パフォーマンスへの影響
```javascript
const MyComponent = () => {
  // この関数は毎回新しく作られる
  const handleClick = () => {
    console.log('clicked');
  };

  return <button onClick={handleClick}>Click me</button>;
};
```

2. 依存配列を持つフックとの相性の問題
```javascript
const MyComponent = () => {
  const [count, setCount] = useState(0);
  
  // この関数は毎回新しく作られるため、useEffectが毎回実行される
  const doSomething = () => {
    console.log(count);
  };

  useEffect(() => {
    doSomething();
  }, [doSomething]); // 依存配列に関数を入れると毎回実行される
};
```

これを解決するには、以下の2つのアプローチがあります：

1. useCallbackを使用してメモ化する：
```javascript
const MyComponent = () => {
  const handleClick = useCallback(() => {
    console.log('clicked');
  }, []); // 依存配列が空なら、関数は1回だけ作られる

  return <button onClick={handleClick}>Click me</button>;
};
```

2. コンポーネントの外で関数を定義する：
```javascript
// コンポーネントの外で定義された関数は再レンダリングの影響を受けない
const handleClick = () => {
  console.log('clicked');
};

const MyComponent = () => {
  return <button onClick={handleClick}>Click me</button>;
};
```

ただし、以下の点に注意が必要です：

- 関数が props や state を使用する必要がある場合は、コンポーネントの外で定義することはできません
- すべての関数をuseCallbackでラップする必要はありません。子コンポーネントがメモ化されていない場合や、関数が頻繁に変更される場合は、useCallbackのオーバーヘッドの方が大きくなる可能性があります
- パフォーマンスの最適化は、実際に問題が確認された場合にのみ行うべきです

つまり、この原則は正しいものの、常にこれらの最適化が必要というわけではありません。具体的なユースケースに応じて適切なアプローチを選択することが重要です。​​​​​​​​​​​​​​​​

## 記事の要約

Kent C. Doddsの「Testing Implementation Details」の記事を要約

### 1. 主要な問題点：
実装の詳細をテストすることには2つの重大な問題がある
- 偽陰性（False negatives）
  - リファクタリング時にテストが壊れる
  - コードは正常に動作しているのにテストが失敗する
- 偽陽性（False positives）
  - コードが壊れているのにテストがパスしてしまう
  - 例：ボタンのクリックハンドラの実装ミスを検出できない

### 2. コンポーネントの2つのユーザー：
1. エンドユーザー
- ブラウザでコンポーネントを実際に操作する人
- レンダリングされた結果（ボタン、コンテンツ）のみを見て操作する

2. 開発者
- コンポーネントにpropsを渡して利用する人
- コンポーネントのAPIを使用する

両者とも内部実装（state名やメソッド名など）を知る必要はない

### 3. 実装例による説明：
- アコーディオンコンポーネントを例に使用
- Enzymeを使用した従来のテスト方法の問題点を示す
  - stateやインスタンスメソッドなど内部実装に依存したテスト
  - リファクタリング（openIndex → openIndexes）でテストが壊れる例を提示

### 4. より良いアプローチ：
- React Testing Libraryの使用を推奨
  - 実装の詳細ではなく、ユーザーの行動と結果に焦点を当てる
  - よりメンテナンスしやすく、信頼性の高いテスト
  - リファクタリングに強い

### 5. 実装の詳細の定義：
- 「実装の詳細とは、コードのユーザーが通常使用せず、見ることもなく、知る必要もないもの」
- テストは実際のユーザーの使用方法に近いほど、より価値がある

### 6. テスト作成のプロセス：
1. 未テストのコードベースで重要な部分を特定
2. テスト対象を具体的な単位に絞る
3. そのコードの「ユーザー」を考える
4. 手動テストの手順を書き出す
5. その手順を自動テストに変換する

このアプローチにより：
- 実装の詳細ではなく、実際の使用パターンに基づいたテスト
- より信頼性が高く、メンテナンスしやすいテスト
- リファクタリングに強いテストを書くことが可能になる​​​​​​​​​​​​​​​​

# 20241206
 - なぜReactはクラスではなく、関数なのか
   - https://zenn.dev/swata_dev/articles/7f8ef4333057d7
   - https://legacy.reactjs.org/docs/hooks-intro.html

記事の要約

1. クラスは人間とマシンの両方を混乱させる（Classes confuse both people and machines）：

- JavaScriptでの`this`の動作が他の言語と大きく異なり、理解が難しい
- イベントハンドラーのバインドを常に意識する必要がある
- ES2022のpublic class fieldsがない場合、コードが冗長になる
- 関数コンポーネントとクラスコンポーネントの使い分けは、経験豊富な開発者の間でも意見が分かれる

2. ツールチェーンとの相性問題：

> Classes present issues for today's tools, too. For example, classes don't minify very well, and they make hot reloading flaky and unreliable.

- クラスは十分にミニファイできない
- ホットリローディングが不安定になる

3. 最適化の課題：

> However, we found that class components can encourage unintentional patterns that make these optimizations fall back to a slower path.

- クラスコンポーネントは意図せずパフォーマンスが低下するパターンを助長する可能性がある

4. Reactの本質との整合性：

> Conceptually, React components have always been closer to functions.

- React コンポーネントは概念的に常に関数に近い存在だった

ただし、記事では以下の点も強調されています：

> There are no plans to remove classes from React.

- Reactからクラスを削除する予定はない
- 既存のクラスコンポーネントは引き続きサポートされる
- Hooksへの移行は段階的に行うことが推奨される

これらの課題に対する解決策として、Hooksが導入され、クラスを使わずにReactの機能を使用できるようになりました。​​​​​​​​​​​​​​​​

# 20241208
## tsconfigのtypeRootsとは
- 型定義ファイル（.d.tsファイル）を探す際のルートディレクトリを指定するための設定
- typeRootsを指定しない場合、デフォルトで./node_modules/@typesが使用される
- サブディレクトリに./node_modulesがある場合は、そちらを優先して使用される
- typeRootsを指定すると、指定したディレクトリのみが型定義の検索対象となる

他気になったことメモ（後で見る）
- https://zenn.dev/qnighy/articles/9a6a0041f2a1aa
- https://qiita.com/tetradice/items/b89a5dd41fcebf96379e

## React Context
- https://github.com/chida09/react-context-sample

# 20141212
## webpackの設定
- Sentryでソースマップを見る都合上、hidden-source-map 指定が理想
- https://webpack.js.org/configuration/devtool/#production

```js
module.exports = composePlugins((config) => {
    if (process.env.NODE_ENV === 'production') {
      config.devtool = 'hidden-source-map';
    } else {
      config.devtool = 'eval';
    }

    return config;
  }
);
```

# 20241214

## 公式ドキュメント

### コンポーネント設計
- 1回しか使わないようなUIコードやマークアップであってもOK
https://ja.react.dev/learn/your-first-component#nesting-and-organizing-components


### デフォルトエクスポート vs 名前付きエクスポート
- どちらでも良い
https://ja.react.dev/learn/importing-and-exporting-components#default-vs-named-exports


### JSXタグが複数あるときにラップしないといけない理由
- JSX は HTML のように見えますが、裏ではプレーンな JavaScript オブジェクトに変換されます。
- 関数から 2 つのオブジェクトを返したい場合、配列でラップしないといけませんよね。
- 2 つの JSX タグを返したい場合に別のタグかフラグメントでラップしないといけないのも、同じ理由です。

以下と同じ原理
```js
// これは構文エラー - 複数の値を直接返そうとしている
function example2() {
  return 42, "hello";  // カンマ演算子として解釈され、最後の値"hello"だけが返される
}

// 複数の値を返したい場合は、配列やオブジェクトでラップする必要がある
function example3() {
  return [42, "hello"]; // これは可能
}
```
- https://ja.react.dev/learn/writing-markup-with-jsx#why-do-multiple-jsx-tags-need-to-be-wrapped


### React はなぜ純粋性を重視するのか？
- 入力値が変化しない場合、レンダーをスキップすることでパフォーマンスを向上できます。
- これが問題ないのは、純関数は常に同じ出力を返すため安全にキャッシュできるからです。
- https://ja.react.dev/learn/keeping-components-pure#why-does-react-care-about-purity


### Reactではコンポーネント固有のメモリのことをstateと呼ぶ
- コンポーネントは、現在の入力値、現在の画像、ショッピングカートの状態といったものを「覚えておく」必要があります。
- https://ja.react.dev/learn/adding-interactivity#state-a-components-memory


### イベントハンドラの命名
- 慣習的に、イベントハンドラは handle の後ろにイベントの名称をつなげた名前にすることが一般的です。
- onClick={handleClick}、onMouseEnter={handleMouseEnter} などがよく見られます。
- https://ja.react.dev/learn/responding-to-events#adding-event-handlers


### イベントハンドラに渡す関数は、渡すべきなのであって呼び出すべきではない
- OK: `<button onClick={handleClick}>`
- NG: `<button onClick={handleClick()}>`
- 2つ目の例では、handleClick() の末尾に () があるため、クリックを必要とせずレンダーの際にすぐに関数を実行します。
- これは、JSX の { と }の中の JavaScript はすぐに実行されるためです。
- https://ja.react.dev/learn/responding-to-events#adding-event-handlers


### イベントハンドラのプロップの命名
- 慣習として、イベントハンドラのプロップは on で始まり、次に大文字の文字が続くようにします。
- たとえば、Button コンポーネントの props である onClick は onSmash と命名することも可能です
- https://ja.react.dev/learn/responding-to-events#naming-event-handler-props


### React アプリでの画面更新は、3つのステップで行われる
- 1.トリガ, 2.レンダー, 3.コミット
- レンダー
  - 初回レンダー時は内部的に[createElement()](https://developer.mozilla.org/ja/docs/Web/API/Document/createElement)を呼び出し、DOMノードを作成する
- コミット
  - 初回レンダー時には、React は [appendChild()](https://developer.mozilla.org/ja/docs/Web/API/Node/appendChild) DOM API を使用して、作成したすべての DOM ノードを画面に表示
- https://ja.react.dev/learn/render-and-commit


### 「レンダーする」とは
- React があなたのコンポーネント（関数）を呼び出すということです。
- 関数から返される JSX は、その時点での UI のスナップショットのようなものです。
- その JSX 内の props、イベントハンドラ、ローカル変数はすべて、レンダー時の state を使用して計算されます。
- https://ja.react.dev/learn/state-as-a-snapshot#rendering-takes-a-snapshot-in-time


### React ではなぜ state の変更が非推奨なのか？
- 最適化：React の一般的な最適化戦略（useMemo）は、前の props や state が次のものと同一である場合作業をスキップする、ということに依存しています。
- state を書き換えないことで、変更があったかどうかを非常に素早くチェックすることができます。prevObj === obj であれば、内部で何も変更されていないと自信を持って言えるようになります。
- https://ja.react.dev/learn/updating-objects-in-state#why-is-mutating-state-not-recommended-in-react
- スプレッド構文は「浅い」、つまり 1 レベルのみのコピーを行う。


### コンポーネントが多くの視覚状態を持つ場合
- それらをすべて 1 つのページに表示することが便利な場合があります。
```js
let statuses = [
  'empty',
  'typing',
  'submitting',
  'success',
  'error',
];
```
- https://ja.react.dev/learn/reacting-to-input-with-state#displaying-many-visual-states-at-once


### props を state にコピーしない
- 親コンポーネントから渡された props と同期されなくなってしまう
- state は最初のレンダー時にのみ初期化されるため
- https://ja.react.dev/learn/choosing-the-state-structure#don-t-mirror-props-in-state


### メモリ使用量の改善
- 理想的には、削除された場所アイテム（およびその子アイテム！）自体も「テーブル」オブジェクトから削除して、メモリ使用量を改善するとよいでしょう。
https://ja.react.dev/learn/choosing-the-state-structure#improving-memory-usage


- 常にコンポーネント関数はトップレベルで宣言し、定義をネストしないようにしてください。
- https://ja.react.dev/learn/preserving-and-resetting-state


### state をリセットする方法は、2 つあります。
- 1. コンポーネントを異なる位置でレンダーする
  - 条件式でComponentを切り替える
  - state は DOM から削除されるたびに破棄される
- 2. key を使って各コンポーネントに明示的な識別子を付与する
  - Componentに異なるkeyの値を指定する
- https://ja.react.dev/learn/preserving-and-resetting-state


### 削除されたコンポーネントの state の保持
- state をリフトアップすることで、親コンポーネントで保持することができます。
- この方法では、重要な情報を保持しているのは親の方なので、子コンポーネントが削除されても問題ありません。
https://ja.react.dev/learn/preserving-and-resetting-state#preserving-state-for-removed-components

# 20141215

## mjs
- .js - デフォルトでCommonJS (CJS)として扱われる
- .mjs - 強制的にECMAScript Modules (ESM)として扱われる
- `vite.config.mts`の記述があったので調べた
- https://vite.dev/guide/troubleshooting.html#vite-cjs-node-api-deprecated

### 参考
- Files ending with .mjs are always loaded as ES modules regardless of package scope.
- Files ending with .cjs are always loaded as CommonJS regardless of package scope.
- Files ending with .js or .mjs, or lacking any extension, will be loaded as ES modules when the nearest parent package.json file contains a top-level field "type" with a value of "module".
- https://nodejs.org/download/release/v13.0.1/docs/api/esm.html
