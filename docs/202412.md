# 20241201
## TS Options
- `esModuleInterop`
- moduleをCommonJSで指定する時
- `import * as myModule from './myModule';`
- `import myModule from './myModule';`
- のように指定できるようになる

詳しくはまた後日調べよう

# 20241204
 - 関数コンポーネントではクロージャ（関数内の関数）は再描画時に参照が変わるため useCallback と使ってメモ化するか、コンポーネントの外で定義するのが推奨される
 - フロントエンドは実装の詳細までテストしないと思っているが、整理したいためこれ読んでおく
   - https://kentcdodds.com/blog/testing-implementation-details
 - GraphQLで型が欲しい場合は、Fragment化すればそれ単体で使える

## 記事の要約

Kent C. Doddsの「Testing Implementation Details」の記事を要約

### 1. 主要な問題点：
実装の詳細をテストすることには2つの重大な問題がある
- 偽陰性（False negatives）
  - リファクタリング時にテストが壊れる
  - コードは正常に動作しているのにテストが失敗する
- 偽陽性（False positives）
  - コードが壊れているのにテストがパスしてしまう
  - 例：ボタンのクリックハンドラの実装ミスを検出できない

### 2. コンポーネントの2つのユーザー：
1. エンドユーザー
- ブラウザでコンポーネントを実際に操作する人
- レンダリングされた結果（ボタン、コンテンツ）のみを見て操作する

2. 開発者
- コンポーネントにpropsを渡して利用する人
- コンポーネントのAPIを使用する

両者とも内部実装（state名やメソッド名など）を知る必要はない

### 3. 実装例による説明：
- アコーディオンコンポーネントを例に使用
- Enzymeを使用した従来のテスト方法の問題点を示す
  - stateやインスタンスメソッドなど内部実装に依存したテスト
  - リファクタリング（openIndex → openIndexes）でテストが壊れる例を提示

### 4. より良いアプローチ：
- React Testing Libraryの使用を推奨
  - 実装の詳細ではなく、ユーザーの行動と結果に焦点を当てる
  - よりメンテナンスしやすく、信頼性の高いテスト
  - リファクタリングに強い

### 5. 実装の詳細の定義：
- 「実装の詳細とは、コードのユーザーが通常使用せず、見ることもなく、知る必要もないもの」
- テストは実際のユーザーの使用方法に近いほど、より価値がある

### 6. テスト作成のプロセス：
1. 未テストのコードベースで重要な部分を特定
2. テスト対象を具体的な単位に絞る
3. そのコードの「ユーザー」を考える
4. 手動テストの手順を書き出す
5. その手順を自動テストに変換する

このアプローチにより：
- 実装の詳細ではなく、実際の使用パターンに基づいたテスト
- より信頼性が高く、メンテナンスしやすいテスト
- リファクタリングに強いテストを書くことが可能になる​​​​​​​​​​​​​​​​

# 20241206
 - なぜReactはクラスではなく、関数なのか
   - https://zenn.dev/swata_dev/articles/7f8ef4333057d7



