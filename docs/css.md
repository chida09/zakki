# CSSスタイリングのベストプラクティス

## 良くない例
1. 要素に直接スタイルを指定する方法：
```html
<!-- HTML -->
<h1>サンプルタイトル</h1>

<!-- CSS -->
h1 { color: red; }
```

**問題点**: もし後でh1をh2に変更する必要が出てきた場合、CSSも修正が必要になります。

## 推奨される方法
2. クラスを使用してスタイルを指定する方法：
```html
<!-- HTML -->
<h1 class="title">サンプルタイトル</h1>

<!-- CSS -->
.title { color: red; }
```

**メリット**: 
- HTMLのタグを変更しても（h1→h2など）、CSSは修正不要
- コードの保守が簡単
- 再利用性が高い

## 例外
以下の要素は直接スタイルを指定しても問題ありません：
- `<a>` リンク
- `<input>` 入力フォーム
- `<textarea>` テキストエリア

理由：これらの要素は他の要素に変更される可能性が低いためです。

## まとめ
タグを直接指定するのではなく、クラスを使ってスタイリングすることで、より柔軟で保守しやすいCSSを書くことができます！


# normalize.css
「normalize.css」というCSSもあります。こちらもブラウザ間での表示の差異をなくすという目的はreset.cssと同じですが、「リセット（初期化）」ではなく「ノーマライズ（統一する）」という名前のとおり、UAスタイルシートの装飾を極力活かしながらブラウザ間の差異のみを埋めていくというアプローチが異なります。


# remとemの違い

`font-size`プロパティの値の単位に使用されることが多いのは`px`や`em`だった。  
CSS3から新しく`rem`という単位が追加された。  
従来の単位である`em`は親要素の`font-size`を1とした倍率を指定する  
`rem`は「root + em」の名前が示すとおり、ルート要素（HTML文書ならhtml要素）の`font-size`を1とした倍率を指定する

```html
<div class="parent">
  親要素のテキスト
  <div class="child">
    子要素のテキスト
  </div>
</div>
```

## emを使用した場合
```css
html {
  font-size: 10px;
}
.parent {
  font-size: 1.2em;    /* 10px(html) * 1.2 = 12px */
}
.child {
  font-size: 1.2em;    /* 12px(parent) * 1.2 = 14.4px */
}
```

## remを使用した場合
```css
html {
  font-size: 10px;
}
.parent {
  font-size: 1.2rem;   /* 10px(html) * 1.2 = 12px */
}
.child {
  font-size: 1.2rem;   /* 10px(html) * 1.2 = 12px */
}
```

親要素の`font-size`プロパティの値を意識せず、常にhtml要素に対する倍率を指定すればいいため管理が楽になる。  
それに加えて、html要素の`font-size`プロパティの値を変更することで、`rem`を使用した箇所すべての`font-size`を相対的に変更することができるため、絶対指定の簡潔さと相対指定の柔軟性を併せ持つことができる  



# マージンの相殺
ブロックレベルの要素の上下のマージンに起こる「マージンの相殺」と呼ばれる挙動がある。  
`display: inline-block;`の要素や`float`がかかっている要素では起きない。  
この現象はブロックレベル要素の上下方向のマージンにのみ適用され、左右のマージンには影響しない

## 隣接したマージンの相殺

隣接した要素の上下のマージンは相殺される。  
マージンが20pxの要素同士が隣り合った場合、その間隔は40pxではなく20pxになる。

```html
<div class="box"></div>
<div class="box"></div>
```

```css
.box {
  margin: 20px;
}
```

この場合、各boxの上下左右に20pxのマージンが設定されryが、隣接する要素間では相殺が発生し、実際の間隔は20pxとなる。

## マージンの値が異なる場合

マージンの値が異なる場合には、大きいほうのマージンが要素の間隔となる。

```html
<div class="box"></div>
<div class="box-large"></div>
```

```css
.box-large {
    margin: 30px;
}
```

この場合、上のboxは20pxのマージン、下のbox-largeは30pxのマージンを持つが、隣接する部分では大きい方の30pxが適用される。

# CSS box-sizingプロパティの解説

box-sizingプロパティは、要素の最終的なサイズがどのように計算されるかを制御する重要なCSSプロパティです。

## 初心者向けの説明

### 通常の箱（content-box）の場合
* あなたが「50cmの箱が欲しい」と言って、50cmの箱を買ったとします
* その箱に「クッション材を2.5cmずつ入れる」と決めた場合
* 結果として箱全体は「55cm」になってしまいます（50cm + 2.5cm × 2）
* これが、CSSのデフォルトの動作（content-box）です

### 新しい考え方の箱（border-box）の場合
* 最初から「クッション材を含めて50cmにしたい」と考えます
* 箱全体が50cmで、その中にクッション材（2.5cm × 2）を入れると
* 実際の収納スペースは自動的に45cmになります
* これが「box-sizing: border-box」の考え方です

## 技術的な説明

### content-box（デフォルト）の特徴
```css
.element {
  width: 300px;
  padding: 20px;
  border: 1px solid #000;
  box-sizing: content-box;
  /* 実際の幅: 300px + (20px * 2) + (1px * 2) = 342px */
}
```
* widthやheightで指定したサイズは、コンテンツ領域だけに適用
* paddingとborderの値は、指定したwidthやheightの値の外側に追加
* 実際の要素幅は「指定width + padding + border」で計算

### border-boxの特徴
```css
.element {
  width: 300px;
  padding: 20px;
  border: 1px solid #000;
  box-sizing: border-box;
  /* 実際の幅: 300px（この中にpadding, borderが含まれる） */
}
```
* widthやheightで指定したサイズに、paddingとborderの値が含まれる
* コンテンツ領域は自動的に「width - padding - border」で計算
* より予測可能なレイアウト設計が可能

## ベストプラクティス
```css
/* Modern Border Box Reset */
*, *::before, *::after {
  box-sizing: border-box;
}
```
* ほとんどのモダンなCSSフレームワークでこのリセットを採用
* レスポンシブデザインの実装が容易
* パーセンテージベースのレイアウトで特に有効

# CSSのline-heightプロパティ

4つの指定方法とその違いについて

1. **normal（初期値）**
- ブラウザが自動的に行の高さを計算します
- 特に指定がない場合のデフォルト値です

2. **数値 + 単位（px, em, remなど）**
- 例：`line-height: 15px;`
- 固定値で行の高さを指定します
- 子要素に継承された場合でも、指定したピクセル値がそのまま適用されます
- ただし、font-sizeが変わった時に行間が不自然になる可能性があるため、あまり推奨されません

3. **パーセント値（%）**
- 例：`line-height: 150%;`
- 親要素のfont-sizeを基準に計算されます
- 計算された値が子要素に継承されます
- 例：font-size: 10pxの要素でline-height: 150%とすると、15pxの行の高さになります

4. **数値のみ（倍率）**
- 例：`line-height: 1.5;`
- **最も推奨される方法**
- 要素自身のfont-sizeを基準に計算されます
- 子要素では、その要素のfont-sizeを基準に再計算されます
- 例：
  - font-size: 10pxの要素 → 15px (10px × 1.5)
  - font-size: 24pxの要素 → 36px (24px × 1.5)

この中で特に**数値のみの指定方法**が推奨される理由は：
- フォントサイズに応じて自動的に適切な行間が設定される
- 継承時も各要素のフォントサイズに応じて相対的に計算される
- レイアウトの一貫性が保ちやすい

ただし、ボタンなどの小さな要素で文字を垂直方向の中央に配置したい場合は、明示的にpxなどの単位付きの値を使用することもあります。

# width

- widthプロパティはその名のとおり、幅を指定するのでwidth: 100px;と指定した要素は幅が100pxになり、中の要素はその幅内で折り返されます。
- min-width: 100px;の場合は最小幅が100pxになるので、中の要素の幅が100px以下の場合は要素幅が100pxになりますが、中の要素の幅が100px以上である場合にはそれにあわせて要素幅も広がります。
- max-width: 100px;の場合は最大幅が100pxになり、中の要素の幅が100px以下の場合はそれにあわせて要素幅も縮みますが、中の要素の幅が100px以上になっても要素幅は100px以上にはならず中の要素が折り返されます。

# vertical-align

vertical-alignプロパティでは要素の縦方向の配置の基準を指定できます。このプロパティはインラインレベルの要素、またはテーブルセルの要素に対してのみ有効です。  
縦方向の配置の基準として、「vertical-alignを指定した要素のどこを親要素のどこに合わせるか」をキーワードや値で指定します。

- baseline: 対象要素のベースラインを親要素のベースラインに揃えます。ベースラインとは欧文書体の基準となるラインで、大部分の英数字の底に位置するラインです。
- middle: 対象要素の中央のラインを親要素の中央のラインに揃えます。

# ダミーテキスト
descriptionの中で使用している「Lorem ipsum」から始まる文は、世界的によく使用される有名なダミーテキストです。  
Lorem ipsumはロレムイプサムと読み、ipsumと読む場合もあります。アルファベットですが英語ではなく、元はラテン語ともいわれていますが、これ自体は意味を持たない文章です。  
文章が未決定の際にダミーテキストを入れる場合は「ダミーテキストダミーテキストダミーテキスト」のような一定の繰り返しよりも、文章の形を持ったテキストを流し込んだほうが実際のテキストを当てはめたときのイメージに近くなるため、Lorem ipsumのような「文章の形は持っているけれど意味を持たないテキスト」が使用されたりします。  
日本語の文章をダミーテキストとして流し込みたい場合は、著作権の切れた小説が使用されることが多いです。

# script要素はhead内?それともbody内?
先ほどまでの説明で、script要素をbody要素内の一番最後に配置しました。パフォーマンス上の理由により、JavaScriptのファイルやコードはドキュメントの最後に読み込むことが推奨されています。  
HTMLドキュメントは上から順に解釈されて描画が行なわれます。そのためHTMLの前や間にJavaScriptの処理が入ると、処理が終わるまでそれ以降のHTMLの描画が止まってしまいます。  
HTMLの描画が終わる前に実行する必要があるJavaScript以外はなるべくbody要素の最後に記述することを推奨します。  

# マルチクラスとCSSプリプロセッサ
マルチクラスとCSSプリプロセッサの比較について

1. マルチクラスの場合
- 1つの要素に複数のクラス（.buttonと.button-showy）を適用
- それぞれのクラスで個別にスタイルを定義
- HTMLのクラス指定が複雑になりやすい欠点がある

1. CSSプリプロセッサ（SassやLESS）を使用した場合
- @extendを使って.buttonのスタイルを継承
- .button-showyで必要な部分だけを上書き
- コードの重複を減らしてシンプルに記述可能

両方のアプローチにそれぞれ利点があり、状況に応じて適切な方法を選択することが重要

# アイコンフォント
アイコンフォントはベクターファイルなので、どれだけ大きく表示してもギザギザとしたジャギーが出ることなく綺麗に表示できます。  
Webページを拡大した際にJPEGやGIFなどの画像は粗く表示されますが、テキストはどこまで拡大しても綺麗なままであるのと同様です。  
ベクターファイルであることにより表示サイズが固定されないほか、高解像度のデバイスで表示した際にも綺麗に表示できるというメリットも非常に大きいです。  
この拡大の話しはSVGでも同様  
  
アイコン用に要素を配置する場合、どの要素を使用すればよいのでしょうか？  
HTML5の仕様には、「アイコンを表わすときはこの要素」といった決まりはありません。要素の定義と矛盾しない範囲であればどの要素を使用してもかまいません。  
ただ、実際にはFont Awesomeのサンプルコードにもあるようにi要素を使用するケースがよく見られます。  
たしかに一貫してそのような文脈で使用されていれば、spanなどの一般的な要素を使用するよりも直感的です。  
しかし、i要素のiは元々 Italic（斜体）の略で、HTML4では囲んだ文字を斜体にするために使用されていた要素です。  
HTML5では意味が変わり「他のテキストとは異なる意味を持つことを表わす」という定義になっています。  
「i要素はアイコンを表わすためにある要素ではない」ということは押さえておきましょう。  

# viewport
viewportは「表示領域」を意味し、スマートフォンでのWebページの表示倍率や領域を制御します。  
PCでは基本的に1倍で表示されますが、スマートフォン（特にiPhone）では、デフォルトのviewport幅（980px）が実際の画面幅（320px）より大きいため、約1/3に自動縮小されて表示されます。  
これを防ぐには、viewportのサイズをデバイスの画面サイズと同じに設定する必要があります。  


# フレックスボックス（flex）
- フレックスボックスは、アイテムを列方向や行方向など一次元に並べて表示するためのレイアウトモデル
- フレックスボックスはでは主軸や交差軸上の配置を指定することができる

## フレックスコンテナー
- display: flex または display: inline-flex を設定することで、その要素（親要素）がフレックスコンテナーになる
  - display: flex ブロックレベルのFlexコンテナーを作成（前後に改行が入る）
  - display: inline-flex インラインレベルのFlexコンテナーを作成（横に並べられる）
- フレックスボックスを使用してレイアウトされた文書の領域をフレックスコンテナーと呼ぶ
  - フレックスコンテナーを作成するには、その領域の display プロパティを flex に設定する

https://developer.mozilla.org/ja/docs/Web/CSS/CSS_flexible_box_layout

### justify-content
- フレックスコンテナーの中で、アイテムをどのように配置・間隔を取るかを決めます
- デフォルトでは横方向（左右）の配置を制御します

### align-items
- フレックスコンテナーの中で、アイテムを上下どの位置に配置するかを決めます
- デフォルトでは縦方向（上下）の配置を制御します

以下の場合、上下左右の中央に配置される

```css
.container {
  display: flex;
  align-items: center;
  justify-content: center;
}
```

## フレックスアイテムの折り返し
- フレックスボックスは一次元のレイアウトとして設計されており、アイテムを単一の行または列として扱います
- flex-wrap プロパティの初期値は nowrap です
- つまり、一連のフレックスアイテムがフレックスコンテナーと比べて幅が広くなると、はみ出してしまいます
- これを折り返すには `flex-wrap: wrap;` を指定します

https://developer.mozilla.org/ja/docs/Web/CSS/CSS_flexible_box_layout/Mastering_wrapping_of_flex_items

### flex-direction
- フレックスコンテナー内のアイテムをどの方向に並べるかを指定するプロパティ
- 文字を横並びから縦並びにしたい時などに使う

https://developer.mozilla.org/ja/docs/Web/CSS/justify-content

# grid
- 2次元レイアウトをHTML/CSS を使って自由に操作できる機能
- display: grid; または display: inline-grid; を指定することで、その要素は Grid Layout のコンテナになる

https://developer.mozilla.org/ja/docs/Glossary/Grid

# vertical-align
- インライン要素のみで利用できる
- 主な使用例は以下
  - テキストの中に画像やアイコンを配置する場合
    - テキストの途中でアイコンがある場合、中央揃えなのか、上方向に揃えるのか決める
  - テーブルのセルでテキストの上下位置を制御する場合
    - 横並びのテーブルのセルでテキストが1行だったり3行だったりする時に、中央揃えなのか、上方向に揃えるのか決める
